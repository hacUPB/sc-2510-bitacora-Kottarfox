#### Actividad 1

1. Aqu√≠ est√° lo que me dio ChatGPT y partes que he agregado yo.
- Entendiendo el programa paso a paso:
Clases principales:
  - Clase Node
     - Representa un nodo de la lista enlazada.
     - Tiene:
float x, y: coordenadas del nodo.
Node* next: puntero al siguiente nodo.
Constructor: inicializa las coordenadas y pone next en nullptr.
Destructor: actualmente no hace nada especial, pero puede extenderse.

  - Clase LinkedList
     - Maneja toda la lista enlazada como una serpiente de nodos.
     - Miembros:
Miembros:
Node* head: inicio de la lista.
Node* tail: final de la lista.
int size: n√∫mero de nodos.
Constructor: crea un nodo en el centro de la pantalla y lo asigna como cabeza y cola.
Destructor: llama a clear() para liberar todos los nodos cuando la lista deja de existir.

M√©todos:
clear(): elimina todos los nodos de la lista uno a uno (gesti√≥n de memoria).
addNode(x, y): crea un nuevo nodo al final de la lista.
update(x, y): mueve el primer nodo a la posici√≥n del mouse, y cada nodo subsiguiente a la posici√≥n del nodo anterior (tipo efecto serpiente).
display(): dibuja todos los nodos como c√≠rculos rojos.

  - Clase ofApp (controlador principal de openFrameworks)
snake: una instancia de LinkedList.
setup(): inicializa el fondo blanco y crea 10 nodos (serpiente de 10 esferas).
update(): actualiza las posiciones de los nodos bas√°ndose en la posici√≥n del mouse.
draw(): dibuja todos los nodos como c√≠rculos.
keyPressed(): si presionas la tecla 'c', limpia toda la lista (y la memoria asociada).

2. Preguntas que me hizo ChatGPT:
1. ¬øQu√© ocurre exactamente cuando se llama a addNode() en la lista enlazada?
R// Se crea un nuevo nodo con new.
 - Si la lista tiene elementos (tail != nullptr):
 - El puntero next del nodo actual al final (tail) se actualiza para apuntar al nuevo nodo.
 - tail se actualiza para que apunte al nuevo nodo (el nuevo final).
 - Si la lista est√° vac√≠a (tail == nullptr):
 - head y tail apuntan ambos al nuevo nodo.
 - Se incrementa el tama√±o de la lista (size++).

¬øQu√© nodo se modifica?
R// Se crea un nuevo nodo con new.

¬øC√≥mo cambia el puntero tail?
R// Si la lista est√° vac√≠a (tail == nullptr): head y tail apuntan ambos al nuevo nodo.

¬øQu√© pasa si la lista estaba vac√≠a?
R// Se incrementa el tama√±o de la lista (size++).

2. ¬øQu√© tipo de puntero es next en la clase Node?
R// next es un puntero crudo (Node*) que apunta al siguiente nodo en la lista.

¬øQu√© pasa si no lo inicializas correctamente?
R// Si usas current->next y no est√° inicializado, puede provocar fallos en tiempo de ejecuci√≥n o accesos ilegales a memoria (segfaults)

¬øC√≥mo evita esto un acceso inv√°lido en tiempo de ejecuci√≥n?
R// Un puntero no inicializado puede contener basura en memoria.

3. ¬øPor qu√© se usa while (current != nullptr) en clear(), update() y display()?
R// Esta condici√≥n recorre toda la lista desde el nodo head hasta el final, deteni√©ndose solo cuando current es nullptr, lo que significa que se ha llegado al √∫ltimo nodo.

¬øQu√© pasar√≠a si us√°ramos while (current->next != nullptr) en su lugar?
R// ¬øQu√© pasar√≠a si us√°ramos while (current->next != nullptr)?
Se omitir√≠a el √∫ltimo nodo, ya que current->next ser√° nullptr justo antes del final.
Esto causar√≠a problemas en:
- clear(): el √∫ltimo nodo nunca se eliminar√≠a, generando una fuga de memoria.
- update(): el √∫ltimo nodo nunca actualizar√≠a su posici√≥n.
- display(): el √∫ltimo nodo no se dibujar√≠a.

4. ¬øQu√© hace exactamente el destructor ~LinkedList() cuando la aplicaci√≥n termina o se destruye el objeto?:
R// Llama al m√©todo clear(), que libera toda la memoria din√°mica reservada para los nodos usando delete.

¬øEn qu√© momento se invoca autom√°ticamente?
R// Se llama autom√°ticamente cuando el objeto snake sale de alcance, por ejemplo, al cerrar el programa o destruir ofApp.

¬øC√≥mo se relaciona con clear()?
R// Llama al m√©todo clear(), que libera toda la memoria din√°mica reservada para los nodos usando delete.

4. Una lista enlazada es una estructura de datos en la que cada elemento (nodo) contiene dos partes:
Un valor (en este caso, las coordenadas x y y).
Un puntero al siguiente nodo en la secuencia (next).
una lista enlazada es m√°s flexible en inserciones/eliminaciones, pero m√°s lenta en accesos aleatorios.

Cuadro de diferencias:
| Caracter√≠stica        | Lista enlazada                                               | Arreglo                                  |
| --------------------- | ------------------------------------------------------------ | ---------------------------------------- |
| Almacenamiento        | Los nodos pueden estar en **cualquier lugar** en la memoria  | Elementos est√°n en **bloques contiguos** |
| Acceso a elementos    | **Secuencial** (hay que recorrer)                            | **Aleatorio** (`arr[i]`) r√°pido          |
| Inserci√≥n/eliminaci√≥n | F√°cil en cualquier parte (O(1) si se tiene el nodo anterior) | Costosa (O(n) por desplazamientos)       |
| Tama√±o                | Din√°mico                                                     | Est√°tico (en arreglos cl√°sicos)          |
| Eficiencia de memoria | Eficiente para inserciones y borrados                        | Mejor si se accede mucho a √≠ndices       |

4. Los nodos est√°n conectados mediante punteros. Cada nodo tiene un puntero llamado next que apunta al siguiente nodo en la lista:
class Node {
public:
    float x, y;
    Node* next; // Apunta al siguiente nodo
};

Cuando se agrega un nodo nuevo con addNode, se hace esto:
tail->next = newNode; // Se enlaza el nodo actual con el nuevo
tail = newNode;       // Se actualiza tail al nuevo nodo
Esta estructura permite que la lista "crezca" de manera din√°mica, un nodo apuntando al siguiente.

5. Los nodos se crean din√°micamente con new:
Node* n = new Node(x, y);  // Reserva memoria en el heap

Y se eliminan con delete:
delete n;  // Libera la memoria ocupada por el nodo

En el c√≥digo:
- addNode() usa new para a√±adir nodos.
- clear() usa delete para liberar la memoria de cada nodo uno por uno.
- El destructor ~LinkedList() llama a clear() para evitar fugas de memoria.

6. 
| Acci√≥n            | Lista enlazada                                      | Arreglo cl√°sico                            |
| ----------------- | --------------------------------------------------- | ------------------------------------------ |
| **Insertar nodo** | R√°pido si se tiene acceso al nodo anterior (`O(1)`) | Lento (`O(n)`) por movimiento de elementos |
| **Eliminar nodo** | R√°pido (`O(1)` con nodo previo)                     | Lento (`O(n)`) por desplazamiento          |
En una lista enlazada no necesitas mover todos los elementos, solo cambias los punteros.

7. La funci√≥n clear() recorre todos los nodos y libera la memoria con delete.
- El destructor ~LinkedList() llama a clear() autom√°ticamente cuando se destruye el objeto.
- Esto garantiza que todos los nodos se eliminen incluso si el usuario no presiona la tecla 'c'.

LinkedList::~LinkedList() {
    clear(); // Libera todos los nodos antes de destruir el objeto
}

8. El c√≥digo en cuesti√≥n:

void LinkedList::clear() {
    Node* current = head;
    while (current != nullptr) {
        Node* nextNode = current->next;
        delete current;           // Libera el nodo actual
        current = nextNode;       // Avanza al siguiente nodo
    }
    head = nullptr;
    tail = nullptr;
    size = 0;
}

- Se empieza con el primer nodo (head).
- Se guarda el siguiente nodo (nextNode) antes de eliminar el actual.
- Se libera el nodo actual (delete current).
- Se repite el proceso hasta que todos los nodos se han eliminado.
- Al final, head y tail se ponen en nullptr, y size a 0.

9. Cada vez que se llama a addNode():
Se crea un nuevo nodo en el heap con new.
El nodo anterior (tail) apunta al nuevo nodo.
tail se actualiza para que apunte al nuevo nodo.
Esto no requiere mover los nodos existentes, a diferencia de un arreglo.

Rendimiento:
Agregar al final es O(1) gracias al puntero tail.
Acceder a un nodo espec√≠fico sigue siendo O(n), ya que hay que recorrer desde el inicio.

10. Aqu√≠ vamos a suponer que estamos desarrollando una herramiento de dibujo donde el usuario puede hacer varias cosas como:
- Agregar puntos (nodos) en cualquier parte del trazo.
- Eliminar puntos intermedios sin afectar el resto del dibujo.

Ahora por que es mejor usar una lista entrelazada? En pocas palabras es mucho m√°s r√°pido de esta forma y no se necesita que se muevan los datos, y como no se sabrian las cantidades de puntos que se puedan poner en este programa es m√°s justo.
En cambio, un arreglo requerir√≠a redimensionarse constantemente, y mover elementos.

11. Imagina una animaci√≥n generativa donde cada nodo representa una part√≠cula con trayectoria din√°mica.
- C√≥mo aplicar√≠as el conocimiento:
Crear una clase ParticleNode que herede de Node, con m√°s propiedades (velocidad, color, etc.).
Usar punteros inteligentes (std::unique_ptr o std::shared_ptr) para evitar olvidar delete.
Crear un m√©todo clear() para limpiar todas las part√≠culas al cerrar o reiniciar la animaci√≥n.

- Consideraciones clave:
Liberar memoria de forma expl√≠cita o autom√°tica.
Evitar fugas asegur√°ndote de que todo nodo que creas tambi√©n se elimina.
Si puedes usar C++ moderno, prefiere punteros inteligentes sobre new/delete manual.

12. 
| Aspecto                 | C++                            | C# u otros con GC                               |
| ----------------------- | ------------------------------ | ----------------------------------------------- |
| Gesti√≥n de memoria      | Manual (`new` / `delete`)      | Autom√°tica (garbage collector)                  |
| Control del programador | Alto control                   | Bajo control (delegado al sistema)              |
| Riesgo de fugas         | Alto si olvidas liberar        | Bajo (aunque pueden haber memory leaks l√≥gicos) |
| Predictibilidad         | M√°s predecible (no hay pausas) | GC puede causar pausas inesperadas              |

- Ventajas de C++:
Control total sobre cu√°ndo y c√≥mo se libera la memoria.
Mejor rendimiento en aplicaciones en tiempo real (como videojuegos o simulaciones visuales).

- Desaf√≠os:
Mayor responsabilidad: si te olvidas de delete, hay fugas.
M√°s f√°cil cometer errores de puntero o acceder a memoria liberada.      

13.
- Consideraciones:
Eliminar nodos obsoletos:
Si una part√≠cula ya no es visible o activa, eliminarla con delete.
Puedes recorrer la lista y borrar selectivamente.

- Reutilizaci√≥n de nodos:
Crear un sistema de ‚Äúpool de objetos‚Äù si los nodos se usan frecuentemente (en vez de destruir y crear siempre).

- Destructor correcto:
Aseg√∫rate de que el destructor de la lista libere todo al cerrar la app.

- Evitar ciclos de punteros:
Aunque esta lista es simple, si se usa next y prev, evita ciclos que impidan liberar correctamente.

- Pruebas de fugas de memoria:
Usar herramientas como Valgrind, o el diagnosticador de memoria de Visual Studio.

- L√≥gica clara de creaci√≥n y destrucci√≥n:
Cada new debe tener un delete eventual.

14. Pruebas que me dio ChatGPT:
üîπ addNode(float x, float y)
Prueba: Llama a addNode() varias veces y verifica que:
size aumenta correctamente.
tail cambia.
Los nodos est√°n bien enlazados (node->next != nullptr).
üìå Usa breakpoints y observa en el depurador los valores de x, y, next.

üîπ update(float x, float y)
Prueba:
Mueve el mouse y observa que el primer nodo sigue al mouse.
Los nodos posteriores siguen la trayectoria.
üìå Usa el depurador para ver c√≥mo se propagan las coordenadas (prevX, prevY).

üîπ clear()
Prueba:
Presiona 'c' en el teclado.
Verifica que:
head y tail son nullptr.
size == 0.
No quedan referencias a nodos en memoria (√∫salo con herramienta de diagn√≥stico).

üîπ Destructor de LinkedList
Prueba:
Deja que el programa termine y observa que clear() se llama desde ~LinkedList().
Usa herramientas de memoria para verificar que no hay fugas.

üîπ Funcionalidad completa
Prueba final:
Ejecuta la app.
Observa c√≥mo se forma la "serpiente".
Presiona 'c' para limpiar.
Verifica que no haya errores, y que la memoria se libere al salir.

Ahora con las que hice yo, admito que le ped√≠ a ChatGPT que me lo pusiera en una tabla por que se ve bonito.
| Funci√≥n         | Resultado esperado                                  | Resultado obtenido        |
| --------------- | --------------------------------------------------- | ------------------------- |
| addNode()     | Se a√±ade nodo al final y aumenta el tama√±o          | ‚úÖ Funciona correctamente  |
| update()`     | Nodos siguen al mouse en cadena                     | ‚úÖ Confirmado en pantalla  |
| clear()       | Elimina todos los nodos, head y tail = nullptr      | ‚úÖ Sin fugas de memoria    |
| ~LinkedList() | Libera memoria al cerrar                            | ‚úÖ Verificado con debugger |
| Aplicaci√≥n    | Se forma una serpiente din√°mica y se limpia con 'c' | ‚úÖ Funcional completo      |


#### Actividad 2
1. Entendiendo la aplicaci√≥n (stack y queue)
Ambos programas crean c√≠rculos que aparecen en pantalla al presionar teclas:

Stack (Pila):
Cada vez que presionas 'a', se apila un nuevo nodo (c√≠rculo) en la parte superior de la pila.
Cada vez que presionas 'd', se desapila (elimina) el nodo superior.
La estructura sigue el orden LIFO (Last In, First Out).

Queue (Cola):
Cada vez que presionas 'a', se encola un nuevo nodo al final de la cola.
Cada vez que presionas 'd', se desencola el nodo del frente.
La estructura sigue el orden FIFO (First In, First Out).
Ambas estructuras usan punteros (Node*) para enlazar los nodos y controlan la memoria din√°micamente con new y delete.

2. Evaluaciones formativas (Stack y Queue)
ChatGPT dijo: Aqu√≠ tienes algunas preguntas con las que puedes autoevaluarte. Usa el depurador de Visual Studio para verificar tus respuestas.

- Stack - Evaluaci√≥n Formativa
¬øQu√© pasa si haces muchas llamadas a push() pero nunca haces pop()?
¬øQu√© valor tiene top despu√©s de hacer un pop() cuando solo hay un nodo?
¬øC√≥mo podr√≠as recorrer la pila sin modificarla?

Queue - Evaluaci√≥n Formativa
¬øQu√© pasa con rear despu√©s de encolar muchos elementos y desencolar todos?
¬øQu√© sucede si haces dequeue() con una cola vac√≠a? ¬øC√≥mo lo manejas?
¬øC√≥mo se comporta front y rear al insertar el primer nodo?

Verifica en el depurador:
Pon breakpoints en push(), pop(), enqueue(), dequeue().
Observa c√≥mo cambian los punteros top, front, rear paso a paso.
Usa la ventana de variables locales para ver si hay fugas (punteros que no se liberan).

3. Pruebas del programa
Stack
Presiona 'a' varias veces y verifica que los c√≠rculos se dibujan en el orden correcto (√∫ltimo arriba).
Presiona 'd' varias veces y aseg√∫rate de que los c√≠rculos desaparecen uno por uno desde arriba.
Haz push() y pop() combinados. Verifica si top apunta al nodo correcto cada vez.

Queue
Presiona 'a' varias veces y verifica que los c√≠rculos se dibujan en orden de llegada.
Presiona 'd' varias veces y aseg√∫rate de que se elimina siempre el primer c√≠rculo agregado.
Encola muchos elementos, luego desencola todos y aseg√∫rate de que la cola queda vac√≠a (front == nullptr y rear == nullptr).

Ahora las respuestras que hice yo siguiendo un formato de hacer, esperar y como lo puedo hacer que se verifique
Prueba 1: Apilar elementos con la tecla 'a'
Qu√© hacer: Presiona varias veces la tecla 'a' en diferentes lugares de la ventana.
Qu√© esperar: Se deben dibujar c√≠rculos donde hiciste clic (√∫ltimo al tope).
C√≥mo verificar: Usa el depurador para ver que cada vez que haces push(), se crea un nuevo nodo con new.
Confirma que top apunta al nodo m√°s reciente.

Prueba 2: Desapilar elementos con la tecla 'd'
Qu√© hacer: Despu√©s de apilar varios nodos, presiona 'd' varias veces.
Qu√© esperar: Los c√≠rculos deben desaparecer en orden inverso al que fueron agregados (LIFO).
C√≥mo verificar:Confirma en el depurador que delete se llama y top se actualiza. Si haces m√°s pop() de los nodos existentes, no deber√≠a crashear.

Prueba 3: Validar liberaci√≥n de memoria
Qu√© hacer: Apila muchos nodos (por ejemplo 1000), luego presiona 'd' hasta vaciar la pila.
Qu√© esperar: No debe haber fugas de memoria si todos los delete se ejecutan correctamente.
Herramienta opcional: Usa un profiler como Valgrind (en Linux) o Visual Studio Diagnostic Tools para confirmar.

Prueba 4: Destructor y clear()
Qu√© hacer: Cierra la aplicaci√≥n con nodos en la pila.
Qu√© esperar: El destructor de Stack debe llamar a clear(), y todos los nodos deben eliminarse.
C√≥mo verificar: Usa puntos de interrupci√≥n en el destructor y clear().

Pruebas para la Queue (Cola)
Prueba 1: Encolar elementos con 'a'
Qu√© hacer: Presiona 'a' varias veces en distintos lugares.
Qu√© esperar: Se dibujan c√≠rculos de izquierda a derecha en orden de llegada.
C√≥mo verificar:El depurador debe mostrar c√≥mo rear->next se actualiza con cada nuevo nodo.front debe mantenerse fijo hasta que se desencole.

Prueba 2: Desencolar con 'd'
Qu√© hacer: Despu√©s de encolar varios elementos, presiona 'd'.
Qu√© esperar: Los c√≠rculos desaparecen en el orden en que fueron encolados (FIFO).
C√≥mo verificar:Verifica que front cambia y delete se llama.Cuando se borra el √∫ltimo nodo, front y rear deben volver a nullptr.

Prueba 3: Verificar que rear y front se comportan correctamente
Qu√© hacer: Encola un solo nodo y luego desenc√≥lalo.
Qu√© esperar: Tanto front como rear deben volver a nullptr.
C√≥mo verificar: Revisa estos valores en el depurador.

Prueba 4: Verificar que clear() en el destructor funciona
Qu√© hacer: Agrega nodos, luego cierra la aplicaci√≥n.
Qu√© esperar: clear() debe llamar a dequeue() repetidamente hasta liberar todos los nodos.

Prueba final de comportamiento completo
¬øFunciona la visualizaci√≥n?
S√≠, display() recorre la estructura y dibuja los c√≠rculos. El orden depender√° de si es stack (√∫ltimo al tope) o queue (primero al frente). Verifica que los c√≠rculos desaparezcan correctamente al eliminar nodos.

¬øHay fugas de memoria?
Si todo est√° bien implementado (como en tu c√≥digo), no deber√≠an haber fugas, pero siempre es buena idea usar herramientas como: Valgrind (Linux), Visual Studio Diagnostic Tools (Windows), Instruments (Mac)

Autoevaluaci√≥n:
1. ¬øPuedo explicar detalladamente c√≥mo funciona el proceso de apilar y desapilar nodos en un stack, incluyendo la gesti√≥n de memoria?
S√≠. Al apilar (push), se crea un nuevo nodo en el heap con new. Este nodo apunta al nodo que antes estaba en la cima (top), y top se actualiza para apuntar al nuevo nodo.
Al desapilar (pop), se elimina el nodo que est√° en top usando delete, y se actualiza top al siguiente nodo. As√≠ se evita una fuga de memoria.

2. ¬øSoy capaz de identificar y corregir una fuga de memoria en una implementaci√≥n de stack manual?
S√≠. Una fuga ocurrir√≠a si no se hace delete en los nodos eliminados. Este c√≥digo evita eso correctamente con delete en pop() y con clear() en el destructor. Si se presentara un error, revisar√≠a si pop() realmente borra el nodo antes de perder la referencia a √©l.

3. ¬øPuedo modificar el stack para que incluya una funci√≥n que busque un elemento espec√≠fico, sin alterar el orden de los elementos apilados?
S√≠. Podr√≠a hacer una funci√≥n como bool find(float x, float y) que recorra la pila sin modificarla:

bool Stack::find(float x, float y) {
    Node* current = top;
    while (current != nullptr) {
        if (current->position.x == x && current->position.y == y) {
            return true;
        }
        current = current->next;
    }
    return false;
}

Esto no altera el orden porque solo se recorre con un puntero temporal.

4. ¬øEntiendo c√≥mo la estructura LIFO del stack afecta el flujo de datos y puedo dar ejemplos de problemas que se resuelvan mejor con un stack?
S√≠. LIFO (Last In, First Out) significa que el √∫ltimo elemento que entra es el primero que sale. Es ideal para problemas como:
Deshacer acciones (√∫ltima acci√≥n se revierte primero).
Recorrido en profundidad (DFS).
Evaluaci√≥n de expresiones matem√°ticas en notaci√≥n postfija.

5. ¬øPuedo implementar y depurar un stack para tipos de datos m√°s complejos, asegur√°ndome de que no haya fugas de memoria ni errores de puntero?
S√≠. Solo habr√≠a que modificar la clase Node para incluir un objeto m√°s complejo, asegurarse de copiarlo correctamente en el constructor, y liberar memoria si se usan punteros internos dentro de ese objeto. Tambi√©n se pueden usar shared_ptr para simplificar.

- Autoevaluaci√≥n 
1. ¬øPuedo explicar claramente el proceso de encolar y desencolar nodos en una queue, incluyendo la gesti√≥n de memoria?
S√≠. Al encolar (enqueue), se crea un nodo con new, se enlaza al final (rear->next = newNode) y se actualiza rear. Si es el primer nodo, tambi√©n se actualiza front.
Al desencolar (dequeue), se elimina el nodo de front usando delete, y se actualiza front. Si la cola queda vac√≠a, rear tambi√©n se pone en nullptr.

2. ¬øSoy capaz de identificar y corregir problemas relacionados con la gesti√≥n de los punteros front y rear en una queue?
S√≠. Los errores comunes incluyen:
No actualizar rear cuando front se vuelve nullptr.
Dejar nodos sin eliminar.
No enlazar bien el nuevo nodo al rear.
En mi c√≥digo, estos casos se manejan correctamente y los verifiqu√© usando el depurador.

3. ¬øPuedo modificar la queue para implementar una queue circular, entendiendo c√≥mo esto afectar√≠a la gesti√≥n de memoria?
S√≠. En una queue circular, el √∫ltimo nodo apunta al primero (rear->next = front), permitiendo reutilizar nodos o hacer estructuras m√°s eficientes sin moverse en memoria constantemente. Requiere manejar con cuidado la condici√≥n de cola llena (en caso de usar tama√±o fijo).

4. ¬øEntiendo c√≥mo la estructura FIFO de una queue afecta el flujo de datos y puedo dar ejemplos de problemas que se resuelvan mejor con una queue?
S√≠. FIFO (First In, First Out) significa que el primer elemento en entrar es el primero en salir. Es √∫til en:
Sistemas de impresi√≥n.
Simulaci√≥n de colas (banco, supermercado).
Recorrido por niveles (BFS en grafos).
Control de tareas pendientes.

5. ¬øPuedo implementar y depurar una queue para tipos de datos m√°s complejos, asegur√°ndome de que no haya fugas de memoria ni errores de puntero?
S√≠. Igual que con el stack, se debe gestionar bien la construcci√≥n y destrucci√≥n de los objetos complejos dentro de los nodos. Usar shared_ptr o unique_ptr tambi√©n puede ayudar a evitar fugas y simplificar la gesti√≥n de memoria.

- Reflexi√≥n
1. En una implementaci√≥n manual de una cola, la memoria se gestiona din√°micamente con new y delete. Cada vez que se encola un nuevo nodo (enqueue), se reserva memoria en el heap con new. Al desencolar (dequeue), se elimina expl√≠citamente ese nodo con delete.
Es crucial tener un destructor (~Queue) que libere todos los nodos restantes, llamando a clear(), para evitar fugas de memoria. Este manejo manual ofrece control total, pero tambi√©n implica mayor riesgo de errores, como olvidarse de liberar memoria o manipular incorrectamente los punteros.

2.La cola requiere mantener dos punteros activos: front (inicio) y rear (final). Esto introduce algunos desaf√≠os adicionales:
Se debe actualizar correctamente front y rear cuando se encolan o desencolan elementos.
Si se desencola el √∫ltimo elemento, rear tambi√©n debe ponerse en nullptr para evitar que apunte a memoria inv√°lida.
Si se olvida actualizar alguno de estos punteros, se puede perder acceso a los nodos, provocando fugas de memoria o dangling pointers.
En contraste, en un stack solo se gestiona el puntero top, lo que simplifica la l√≥gica.

3. La estructura FIFO garantiza que el primer elemento que entra es el primero que sale. Esto refleja c√≥mo funcionan muchas situaciones del mundo real: colas en tiendas, procesos en sistemas operativos, tareas en servidores.
La FIFO es esencial en:
Simulaci√≥n de sistemas de espera.
Control de tareas o eventos en orden cronol√≥gico.
Algoritmos como Breadth-First Search (BFS) en grafos.
Permite mantener un flujo ordenado y justo, especialmente cuando el orden de llegada es importante.

4.Una queue circular conecta el √∫ltimo nodo al primero (rear->next = front), formando un bucle. Esto tiene varias ventajas:
Reutilizaci√≥n eficiente del espacio: en lugar de mover elementos o hacer shift, se puede sobrescribir nodos anteriores si ya han sido usados.
Menor fragmentaci√≥n de memoria en estructuras de tama√±o fijo (como en buffers).
Puede reducir la necesidad de asignaciones y liberaciones constantes de memoria.
Para implementarla, habr√≠a que ajustar la condici√≥n de finalizaci√≥n y manipular los punteros front y rear para que recorran el ciclo sin sobrescribir nodos no procesados.

5. Los errores m√°s comunes incluyen:
Fugas de memoria: si dequeue() no hace delete o se pierde la referencia al nodo.
Punteros colgantes: si rear sigue apuntando a un nodo ya eliminado.
Acceso a memoria inv√°lida: si se intenta acceder a front o rear cuando la cola est√° vac√≠a.

Para evitarlos:
Siempre verificar si front == nullptr antes de acceder.
Al desencolar el √∫ltimo nodo, asegurarse de poner tambi√©n rear = nullptr.
Inicializar ambos punteros en el constructor (nullptr).
Usar funciones como clear() en el destructor para limpiar toda la memoria.

- Autoevaluaci√≥n 
1. S√≠. En el proceso de encolar (enqueue), se crea un nuevo nodo con new, y si la cola est√° vac√≠a (rear == nullptr), tanto front como rear apuntan a este nuevo nodo. Si no est√° vac√≠a, el nuevo nodo se enlaza al final (rear->next = newNode) y luego rear se actualiza.
En el proceso de desencolar (dequeue), se guarda el nodo en una variable temporal, se actualiza front = front->next, y luego se elimina el nodo con delete. Si despu√©s de desencolar la cola queda vac√≠a (front == nullptr), tambi√©n se pone rear = nullptr.
Este manejo manual requiere atenci√≥n para evitar errores como p√©rdidas de memoria o punteros colgantes.

2. S√≠. Puedo reconocer que:
Si rear no se pone en nullptr cuando la cola se vac√≠a, se puede tener un puntero inv√°lido.
Si se pierde la referencia al nodo actual antes de hacer delete, se produce una fuga de memoria.
Si no se actualiza rear correctamente al encolar, el nuevo nodo no se conecta correctamente.
Estas situaciones pueden corregirse agregando condiciones claras en dequeue() y enqueue() para actualizar los punteros seg√∫n el estado de la cola. Tambi√©n puedo utilizar el depurador para observar el comportamiento de front y rear en tiempo real.

3. S√≠. Para implementar una queue circular, har√≠a que el √∫ltimo nodo (rear) apunte al primero (front). Esto requiere:
Cambiar el comportamiento de enqueue() para que rear->next = front.
Modificar la l√≥gica de dequeue() para actualizar correctamente front y, si la cola se vac√≠a, romper el ciclo (rear = nullptr).
Tener cuidado de no recorrer infinitamente la estructura si se usa en bucles (do while).
El mayor impacto es que ya no se puede usar nullptr como se√±al de final, por lo que se requiere una condici√≥n alternativa para detectar que se ha completado una vuelta. Este tipo de estructura es √∫til en buffers circulares y simulaciones de recursos finitos.

4. S√≠. La estructura FIFO (First In, First Out) permite que el primer elemento insertado sea el primero en salir, lo que la hace ideal para:
Sistemas de impresi√≥n (impresora procesa tareas en orden de llegada).
Simulaci√≥n de filas o turnos (como en bancos, supermercados).
Gesti√≥n de procesos en sistemas operativos.
Algoritmos como Breadth-First Search (BFS), donde se exploran nodos en capas.
A diferencia de un stack (LIFO), la queue garantiza equidad temporal y procesamiento en orden cronol√≥gico.

5. S√≠. Para implementar una queue con datos m√°s complejos (por ejemplo, una clase Persona con nombre, edad, etc.), puedo:
Modificar el nodo para contener un objeto o puntero al objeto.
Si se usa un puntero (Persona*), asegurarme de liberar la memoria en el destructor del nodo.
En el destructor de la cola, llamar a delete de cada nodo y su contenido si es din√°mico.
Utilizar el depurador o herramientas como Visual Leak Detector o Valgrind (en Linux) para verificar que no haya fugas de memoria.
Tambi√©n podr√≠a usar shared_ptr o unique_ptr si se permite usar C++ moderno, lo que facilita la gesti√≥n de memoria.

- RETO -
- Exploraci√≥n creativa: Remolino de esferas de color (ooohhh)
Visualiza un remolino de esferas de colores que giran alrededor del centro de la pantalla. Las esferas nuevas se apilan desde el centro hacia afuera (estructura: pila). Una lista enlazada mantiene la velocidad de rotaci√≥n y color de cada esfera. Puedes interactuar con el teclado para agregar o quitar esferas, y el movimiento se acelera o desacelera con las flechas.

1. Combinaci√≥n de estructuras de datos
Pila: Guarda las posiciones radiales de las esferas que se van apilando desde el centro hacia afuera. Cada vez que se agrega una esfera, se "push" a la pila la posici√≥n.
Lista enlazada: Controla atributos din√°micos de cada esfera, como el color y la velocidad individual de rotaci√≥n. Esta lista enlazada se maneja manualmente, sin STL.
Gesti√≥n din√°mica: Ambas estructuras crean y destruyen nodos usando new y delete para gesti√≥n expl√≠cita de memoria.

2. Interactividad
Teclas para interactuar:
'a': agrega una nueva esfera (apil√°ndola).
'd': elimina la √∫ltima esfera (desapilando).
Flechas arriba y abajo para aumentar o disminuir la velocidad de rotaci√≥n general.
La interacci√≥n cambia el comportamiento y la visualizaci√≥n del remolino en tiempo real, generando dinamismo.

3. Gesti√≥n de memoria
Cada nodo de la pila y lista enlazada se elimina correctamente usando delete cuando desaparece un nodo.
En el destructor de cada estructura se limpia toda la memoria din√°mica.
No se usan punteros "colgantes" o sin liberar, evitando fugas.

4. Otros detalles importantes
Se usa movimiento din√°mico: la rotaci√≥n de cada esfera se actualiza en update().
Visualizaci√≥n gr√°fica de las esferas con colores variables.
Estructuras de datos expl√≠citas, sin STL, para evidenciar comprensi√≥n profunda.

Ahora el moridero, el c√≥digo: 
Para ofApp.h

#pragma once
#include "ofMain.h"

// Nodo para la lista enlazada (atributos de cada esfera)
class SphereNode {
public:
    ofColor color;
    float rotationSpeed;
    SphereNode* next;

    SphereNode(ofColor c, float speed) {
        color = c;
        rotationSpeed = speed;
        next = nullptr;
    }
};

// Lista enlazada para controlar atributos din√°micos de las esferas
class SphereList {
public:
    SphereNode* head;

    SphereList() {
        head = nullptr;
    }

    ~SphereList() {
        clear();
    }

    void add(ofColor c, float speed) {
        SphereNode* newNode = new SphereNode(c, speed);
        newNode->next = head;
        head = newNode;
    }

    void removeLast() {
        if (!head) return;
        if (!head->next) {
            delete head;
            head = nullptr;
            return;
        }
        SphereNode* current = head;
        while (current->next && current->next->next) {
            current = current->next;
        }
        delete current->next;
        current->next = nullptr;
    }

    void clear() {
        while (head) {
            SphereNode* temp = head;
            head = head->next;
            delete temp;
        }
    }
};

// Nodo para la pila (posici√≥n radial)
class PositionNode {
public:
    float radius;
    PositionNode* next;

    PositionNode(float r) {
        radius = r;
        next = nullptr;
    }
};

// Pila para almacenar posiciones radiales de esferas
class PositionStack {
public:
    PositionNode* top;

    PositionStack() {
        top = nullptr;
    }

    ~PositionStack() {
        clear();
    }

    void push(float r) {
        PositionNode* newNode = new PositionNode(r);
        newNode->next = top;
        top = newNode;
    }

    void pop() {
        if (top != nullptr) {
            PositionNode* temp = top;
            top = top->next;
            delete temp;
        }
    }

    void clear() {
        while (top != nullptr) {
            pop();
        }
    }
};

class ofApp : public ofBaseApp {
public:
    PositionStack posStack;    // Posiciones radiales de esferas
    SphereList sphereList;     // Atributos (color, velocidad)

    float baseRotation;        // √Ångulo base de rotaci√≥n global
    float rotationSpeed;       // Velocidad de rotaci√≥n global

    void setup();
    void update();
    void draw();
    void keyPressed(int key);

private:
    void drawSpheres();
};


- ofApp.cpp

#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
	ofSetBackgroundColor(30);
	baseRotation = 0;
	rotationSpeed = 0.02f;
}

//--------------------------------------------------------------
void ofApp::update() {
	baseRotation += rotationSpeed;
}

//--------------------------------------------------------------
void ofApp::draw() {
	ofTranslate(ofGetWidth() / 2, ofGetHeight() / 2); // Centro pantalla
	drawSpheres();
}

// Dibuja todas las esferas, combinando posiciones de pila y atributos de lista
void ofApp::drawSpheres() {
	PositionNode * posNode = posStack.top;
	SphereNode * sphereNode = sphereList.head;

	int index = 0;
	while (posNode != nullptr && sphereNode != nullptr) {
		float angle = baseRotation * (index + 1); // √Ångulo con rotaci√≥n
		float x = posNode->radius * cos(angle);
		float y = posNode->radius * sin(angle);

		ofSetColor(sphereNode->color);
		float radius = 15 + 5 * sin(ofGetElapsedTimef() * sphereNode->rotationSpeed); // Tama√±o din√°mico

		ofDrawCircle(x, y, radius);

		posNode = posNode->next;
		sphereNode = sphereNode->next;
		index++;
	}
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
	if (key == 'a') {
		// Agregar esfera: nueva posici√≥n radial y atributos (color y velocidad aleatorios)
		float newRadius = posStack.top ? (40 + posStack.top->radius + 20) : 40;

		posStack.push(newRadius);

		ofColor newColor = ofColor::fromHsb(ofRandom(0, 255), 200, 255);
		float newSpeed = ofRandom(0.5, 2.0);
		sphereList.add(newColor, newSpeed);
	} else if (key == 'd') {
		// Eliminar √∫ltima esfera: desapilar y eliminar nodo atributo
		posStack.pop();
		sphereList.removeLast();
	} else if (key == OF_KEY_UP) {
		// Incrementar velocidad rotaci√≥n global
		rotationSpeed += 0.01f;
	} else if (key == OF_KEY_DOWN) {
		// Disminuir velocidad rotaci√≥n global (m√≠nimo 0)
		rotationSpeed = max(0.f, rotationSpeed - 0.01f);
	}
}

y Main.cpp

#include "ofApp.h"
#include "ofMain.h"

//========================================================================
int main() {
	ofSetupOpenGL(1024, 768, OF_WINDOW); // Ventana de 1024x768
	ofRunApp(new ofApp()); // Lanza la app principal
}

(comentarios gracias ChatGpt)

RAE1:
- Se us√≥ una pila (PositionStack) para controlar la posici√≥n radial de cada esfera desde el centro hacia afuera, permitiendo que el √∫ltimo agregado sea el m√°s externo.
- Se us√≥ una lista enlazada (SphereList) para guardar atributos visuales y de movimiento de cada esfera (color y velocidad de oscilaci√≥n).
- El m√©todo drawSpheres() itera simult√°neamente en ambas estructuras para dibujar cada esfera en la posici√≥n correspondiente con sus propiedades.
- La interacci√≥n con el usuario agrega y elimina esferas, adem√°s de cambiar la velocidad de rotaci√≥n global.
- La gesti√≥n de memoria es manual, liberando los nodos correctamente al eliminar elementos o al destruir las estructuras.
- Esto evidencia el cumplimiento del RAE1: construcci√≥n de aplicaci√≥n interactiva con patrones y estructuras de datos combinadas y gesti√≥n expl√≠cita de memoria.

RAE2 (Con ayuda de ChatGPT para las preguntas)

- Prueba de agregado y eliminaci√≥n de esferas:
Presiona 'a' varias veces y verifica que las esferas aparecen correctamente y se dibujan con colores y movimientos distintos.
Presiona 'd' para eliminar y observa que desaparecen sin errores o fugas.
Usa el depurador para verificar que los nodos se crean y destruyen correctamente.

- Prueba de velocidad:
Usa flechas arriba y abajo para acelerar o desacelerar la rotaci√≥n.
Asegura que la velocidad no sea negativa y que la rotaci√≥n se comporte como se espera.
Prueba de gesti√≥n de memoria:
Cierra la aplicaci√≥n con varias esferas y revisa con herramientas o el depurador que no haya fugas de memoria.
Verifica que el destructor de las estructuras libera todos los nodos.

- Capturas de pantalla:
Muestra varias esferas girando con diferentes colores.
Muestra cambios con la interacci√≥n (agregar, eliminar, cambiar velocidad).

Ahora las respuestas:
Prueba de creaci√≥n y eliminaci√≥n de esferas
Procedimiento:
Presionar repetidamente la tecla 'a' para agregar esferas.
Observar que cada esfera aparece en pantalla con color y tama√±o din√°mico.
Presionar la tecla 'd' para eliminar esferas una por una.
Confirmar que las esferas desaparecen en orden inverso al agregado (LIFO de pila).

Resultado esperado:
Cada esfera nueva se agrega con posici√≥n radial incrementada.
Al eliminar, la √∫ltima esfera agregada desaparece primero.
No ocurren errores ni bloqueos al agregar o eliminar.

Evidencia:
Captura de pantalla con varias esferas en pantalla.
Captura mostrando la reducci√≥n de esferas tras presionar 'd'.

2. Prueba de interacci√≥n con la velocidad de rotaci√≥n
Procedimiento:
Presionar tecla flecha arriba para aumentar la velocidad de rotaci√≥n global.
Presionar tecla flecha abajo para disminuir la velocidad (hasta 0).
Observar el cambio visual en la velocidad de giro de todas las esferas.

Resultado esperado:
La velocidad no debe ser negativa.
La aplicaci√≥n responde sin retrasos ni saltos bruscos.

Evidencia:
Captura mostrando las esferas girando lento.
Captura mostrando esferas girando r√°pido tras aumentar velocidad.

3. Prueba de gesti√≥n y liberaci√≥n de memoria
Procedimiento:
Utilizar un profiler o herramienta de detecci√≥n de fugas de memoria (como Valgrind o herramientas integradas en IDEs).
Ejecutar la aplicaci√≥n agregando y eliminando muchas esferas.
Cerrar la aplicaci√≥n y verificar que no queden fugas.

Resultado esperado:
No se detectan fugas de memoria.
Los destructores de lista y pila liberan todos los nodos correctamente.

Evidencia:
Captura o reporte del profiler mostrando cero fugas.
Captura de consola al cerrar la aplicaci√≥n sin errores.

4. Prueba de comportamiento integrado
Procedimiento:
Combinar las interacciones: agregar, eliminar esferas y cambiar la velocidad de rotaci√≥n en diferentes momentos.
Observar que no se producen fallos o comportamientos inesperados.
Confirmar que la experiencia visual es fluida y coherente.

Resultado esperado:
La aplicaci√≥n mantiene estabilidad y fluidez.
Las estructuras de datos sincronizan correctamente el estado.
No hay crashes ni errores gr√°ficos.

Evidencia:
Capturas de pantalla con distintas configuraciones y estados.
Video corto mostrando la interacci√≥n completa: https://youtu.be/rwb3L1j9EOk
















